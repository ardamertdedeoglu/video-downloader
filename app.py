from flask import Flask, render_template, request, jsonify, send_file, session, send_from_directory
import yt_dlp
import os
import uuid
import threading
import re
import sys
import time
import string
import random
import secrets

print("[DEBUG] Starting app initialization...", file=sys.stderr)

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', 'dev-secret-key-change-in-production')
app.config['MAX_CONTENT_LENGTH'] = 1 * 1024 * 1024  # 1MB max cookie file

# ============ Extension Token Management ============
# Pairing tokens: geçici kodlar (10 dakika TTL)
# {pairing_code: {'user_session_id': str, 'created_at': float}}
pairing_tokens = {}

# Extension tokens: kalıcı tokenlar
# {extension_token: {'user_session_id': str, 'browser': str, 'paired_at': float, 'last_sync': float}}
extension_tokens = {}

# Rate limiting: extension_token -> [timestamp1, timestamp2, ...]
rate_limits = {}

# Sabitler
PAIRING_TOKEN_TTL = 600  # 10 dakika
RATE_LIMIT_WINDOW = 60  # 1 dakika
RATE_LIMIT_MAX_REQUESTS = 2  # dakikada max 2 istek

def generate_pairing_code():
    """6 haneli alfanumerik pairing kodu üret"""
    chars = string.ascii_uppercase + string.digits
    # Karışıklığı önlemek için benzer karakterleri çıkar (0, O, I, 1, L)
    chars = chars.replace('0', '').replace('O', '').replace('I', '').replace('1', '').replace('L', '')
    return ''.join(random.choices(chars, k=6))

def generate_extension_token():
    """Güvenli extension token üret"""
    return f"ext_{secrets.token_urlsafe(32)}"

def cleanup_expired_tokens():
    """Süresi dolmuş pairing token'ları temizle"""
    current_time = time.time()
    expired = [code for code, data in pairing_tokens.items() 
               if current_time - data['created_at'] > PAIRING_TOKEN_TTL]
    for code in expired:
        del pairing_tokens[code]
    return len(expired)

def check_rate_limit(extension_token):
    """Rate limit kontrolü - dakikada max 2 istek"""
    current_time = time.time()
    
    if extension_token not in rate_limits:
        rate_limits[extension_token] = []
    
    # Eski timestamplari temizle
    rate_limits[extension_token] = [
        ts for ts in rate_limits[extension_token] 
        if current_time - ts < RATE_LIMIT_WINDOW
    ]
    
    # Limit kontrolü
    if len(rate_limits[extension_token]) >= RATE_LIMIT_MAX_REQUESTS:
        oldest = min(rate_limits[extension_token])
        retry_after = int(RATE_LIMIT_WINDOW - (current_time - oldest)) + 1
        return False, retry_after
    
    # Yeni istek ekle
    rate_limits[extension_token].append(current_time)
    return True, 0

def cookies_to_netscape(cookies):
    """JSON cookie array'ini Netscape formatına çevir"""
    lines = ["# Netscape HTTP Cookie File", "# https://curl.haxx.se/rfc/cookie_spec.html", "# This file was generated by Video Downloader Extension", ""]
    
    for cookie in cookies:
        domain = cookie.get('domain', '')
        # Domain başında nokta yoksa ekle (subdomain eşleşmesi için)
        if domain and not domain.startswith('.'):
            domain = '.' + domain
        
        flag = 'TRUE' if domain.startswith('.') else 'FALSE'
        path = cookie.get('path', '/')
        secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
        
        # Expiration: -1 veya None ise session cookie, 0 yapabiliriz
        expiration = cookie.get('expirationDate', 0)
        if expiration is None or expiration < 0:
            expiration = 0
        else:
            expiration = int(expiration)
        
        name = cookie.get('name', '')
        value = cookie.get('value', '')
        
        if name and domain:
            line = f"{domain}\t{flag}\t{path}\t{secure}\t{expiration}\t{name}\t{value}"
            lines.append(line)
    
    return '\n'.join(lines)

# Download klasörü
DOWNLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'downloads')
try:
    if not os.path.exists(DOWNLOAD_FOLDER):
        os.makedirs(DOWNLOAD_FOLDER)
except Exception as e:
    print(f"Warning: Could not create downloads folder: {e}")

# Cookie dosyası klasörü
COOKIE_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'cookies')
try:
    if not os.path.exists(COOKIE_FOLDER):
        os.makedirs(COOKIE_FOLDER)
except Exception as e:
    print(f"Warning: Could not create cookies folder: {e}")

# İndirme durumlarını takip etmek için
download_status = {}

# Bellek temizliği için eski download'ları sil
def cleanup_old_downloads():
    """1 saatten eski download durumlarını temizle"""
    current_time = time.time()
    expired = [did for did, data in download_status.items() 
               if current_time - data.get('created_at', current_time) > 3600]
    for did in expired:
        del download_status[did]
    return len(expired)

# Ortam tespiti
IS_SERVER = os.environ.get('RAILWAY_ENVIRONMENT') or os.environ.get('RENDER') or os.environ.get('FLY_APP_NAME')

print(f"[DEBUG] IS_SERVER: {IS_SERVER}", file=sys.stderr)

def get_ydl_opts(cookie_file=None):
    """yt-dlp ayarları"""
    opts = {
        'quiet': False,
        'verbose': True,
        'no_warnings': False,
        'age_limit': None,
        'cachedir': False,
        'http_headers': {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        }
    }
    
    # Cookie dosyası varsa kullan
    if cookie_file:
        if os.path.exists(cookie_file):
            opts['cookiefile'] = cookie_file
            print(f"[DEBUG] Using cookie file: {cookie_file}", file=sys.stderr)
        else:
            print(f"[DEBUG] Cookie file path provided but file not found: {cookie_file}", file=sys.stderr)
    # Yerel ortamda tarayıcı cookie'si kullan
    elif not IS_SERVER:
        for browser in ['firefox', 'chrome', 'edge', 'brave']:
            try:
                opts['cookiesfrombrowser'] = (browser,)
                print(f"[DEBUG] Using browser cookies: {browser}", file=sys.stderr)
                break
            except:
                continue
    else:
        print(f"[DEBUG] No cookie file provided to get_ydl_opts", file=sys.stderr)

    
    return opts

def sanitize_filename(filename):
    """Dosya adından geçersiz karakterleri temizle"""
    return re.sub(r'[<>:"/\\|?*]', '', filename)

def get_video_info(url, cookie_file=None):
    """Video bilgilerini al"""
    ydl_opts = get_ydl_opts(cookie_file)
    ydl_opts['extract_flat'] = False
    
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=False)
        
        # Mevcut formatları logla
        available_formats = info.get('formats', [])
        print(f"[DEBUG] Available formats count: {len(available_formats)}", file=sys.stderr)
        for f in available_formats[:5]:  # İlk 5 formatı göster
            print(f"[DEBUG] Format: {f.get('format_id')} - {f.get('ext')} - {f.get('height')}p", file=sys.stderr)
        
        formats = [
            {'format_id': 'best', 'quality': 'En İyi Kalite', 'ext': 'mp4', 'type': 'video+audio'},
            {'format_id': '1080p', 'quality': '1080p (Full HD)', 'ext': 'mp4', 'type': 'video+audio'},
            {'format_id': '720p', 'quality': '720p (HD)', 'ext': 'mp4', 'type': 'video+audio'},
            {'format_id': '480p', 'quality': '480p', 'ext': 'mp4', 'type': 'video+audio'},
            {'format_id': '360p', 'quality': '360p', 'ext': 'mp4', 'type': 'video+audio'},
            {'format_id': 'bestaudio', 'quality': 'Sadece Ses (M4A)', 'ext': 'm4a', 'type': 'audio'},
        ]
        
        return {
            'title': info.get('title', 'Bilinmeyen'),
            'thumbnail': info.get('thumbnail'),
            'duration': info.get('duration'),
            'uploader': info.get('uploader', 'Bilinmeyen'),
            'view_count': info.get('view_count'),
            'formats': formats,
            'age_restricted': info.get('age_limit', 0) >= 18
        }

def download_video(url, format_id, download_id, cookie_file=None):
    """Video indir"""
    print(f"[DEBUG] Starting download for {download_id} with cookie: {cookie_file}", file=sys.stderr)
    download_status[download_id] = {
        'status': 'downloading', 
        'progress': 0, 
        'filename': None,
        'created_at': time.time()
    }
    
    def progress_hook(d):
        if d['status'] == 'downloading':
            total = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
            downloaded = d.get('downloaded_bytes', 0)
            if total > 0:
                download_status[download_id]['progress'] = int((downloaded / total) * 100)
        elif d['status'] == 'finished':
            download_status[download_id]['progress'] = 100

    output_template = os.path.join(DOWNLOAD_FOLDER, f'{download_id}_%(title)s.%(ext)s')
    
    # Basitleştirilmiş format seçenekleri
    if format_id == 'bestaudio':
        format_string = 'bestaudio/best'
    elif format_id == '1080p':
        format_string = 'bv*[height<=1080]+ba/b[height<=1080]/b'
    elif format_id == '720p':
        format_string = 'bv*[height<=720]+ba/b[height<=720]/b'
    elif format_id == '480p':
        format_string = 'bv*[height<=480]+ba/b[height<=480]/b'
    elif format_id == '360p':
        format_string = 'bv*[height<=360]+ba/b[height<=360]/b'
    else:  # best
        format_string = 'bv*+ba/b'
    
    print(f"[DEBUG] Using format string: {format_string}", file=sys.stderr)
    
    ydl_opts = get_ydl_opts(cookie_file)
    ydl_opts.update({
        'format': format_string,
        'outtmpl': output_template,
        'progress_hooks': [progress_hook],
        'merge_output_format': 'mp4',
        # FFmpeg ayarları
        'prefer_ffmpeg': True,
        'postprocessor_args': {
            'ffmpeg': ['-c:v', 'copy', '-c:a', 'aac']
        },
    })
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            ydl.download([url])
        
        for filename in os.listdir(DOWNLOAD_FOLDER):
            if filename.startswith(download_id):
                download_status[download_id]['status'] = 'completed'
                download_status[download_id]['filename'] = filename
                return
        
        download_status[download_id]['status'] = 'error'
        download_status[download_id]['error'] = 'Dosya bulunamadı'
    except Exception as e:
        download_status[download_id]['status'] = 'error'
        download_status[download_id]['error'] = str(e)

# ============ Cookie Upload Routes ============

@app.route('/api/cookie/upload', methods=['POST'])
def upload_cookie():
    """Cookie dosyası yükle"""
    if 'cookie_file' not in request.files:
        return jsonify({'error': 'Cookie dosyası gerekli'}), 400
    
    file = request.files['cookie_file']
    if file.filename == '':
        return jsonify({'error': 'Dosya seçilmedi'}), 400
    
    # Session ID oluştur veya mevcut olanı kullan
    if 'session_id' not in session:
        session['session_id'] = str(uuid.uuid4())
    
    session_id = session['session_id']
    cookie_path = os.path.join(COOKIE_FOLDER, f'{session_id}.txt')
    
    try:
        content = file.read().decode('utf-8')
        
        # Netscape cookie formatını kontrol et
        if '# Netscape HTTP Cookie File' not in content and '.youtube.com' not in content:
            return jsonify({'error': 'Geçersiz cookie dosyası formatı. Netscape formatında olmalı.'}), 400
        
        with open(cookie_path, 'w') as f:
            f.write(content)
        
        session['has_cookies'] = True
        print(f"[DEBUG] Cookie uploaded for session: {session_id}", file=sys.stderr)
        print(f"[DEBUG] Cookie file size: {len(content)} bytes", file=sys.stderr)
        if content:
            print(f"[DEBUG] Cookie first line: {content.splitlines()[0]}", file=sys.stderr)
        
        return jsonify({'success': True, 'message': 'Cookie dosyası başarıyla yüklendi'})
    except Exception as e:
        return jsonify({'error': f'Cookie yüklenirken hata: {str(e)}'}), 500

@app.route('/api/cookie/status')
def cookie_status():
    """Cookie durumunu kontrol et"""
    session_id = session.get('session_id')
    has_cookies = False
    
    if session_id:
        cookie_path = os.path.join(COOKIE_FOLDER, f'{session_id}.txt')
        has_cookies = os.path.exists(cookie_path)
    
    return jsonify({
        'has_cookies': has_cookies,
        'session_id': session_id
    })

@app.route('/api/cookie/delete', methods=['POST'])
def delete_cookie():
    """Cookie dosyasını sil"""
    session_id = session.get('session_id')
    if session_id:
        cookie_path = os.path.join(COOKIE_FOLDER, f'{session_id}.txt')
        if os.path.exists(cookie_path):
            os.remove(cookie_path)
    
    session.pop('has_cookies', None)
    return jsonify({'success': True})

def get_user_cookie_file():
    """Kullanıcının cookie dosyasını al"""
    session_id = session.get('session_id')
    print(f"[DEBUG] get_user_cookie_file - Session ID: {session_id}", file=sys.stderr)
    
    if session_id:
        cookie_path = os.path.join(COOKIE_FOLDER, f'{session_id}.txt')
        exists = os.path.exists(cookie_path)
        print(f"[DEBUG] Checking cookie path: {cookie_path}, Exists: {exists}", file=sys.stderr)
        if exists:
            return cookie_path
    return None

# ============ Extension API Routes ============

@app.route('/api/extension/generate-token', methods=['POST'])
def generate_token():
    """Pairing kodu oluştur (10 dakika geçerli)"""
    # Önce süresi dolmuş tokenları temizle
    cleanup_expired_tokens()
    
    # Session ID oluştur veya mevcut olanı kullan
    if 'session_id' not in session:
        session['session_id'] = str(uuid.uuid4())
    
    user_session_id = session['session_id']
    
    # Yeni pairing kodu oluştur
    pairing_code = generate_pairing_code()
    
    # Aynı kullanıcının önceki pairing kodlarını sil
    old_codes = [code for code, data in pairing_tokens.items() 
                 if data['user_session_id'] == user_session_id]
    for code in old_codes:
        del pairing_tokens[code]
    
    # Yeni kodu kaydet
    pairing_tokens[pairing_code] = {
        'user_session_id': user_session_id,
        'created_at': time.time()
    }
    
    print(f"[DEBUG] Generated pairing code: {pairing_code} for session: {user_session_id}", file=sys.stderr)
    
    return jsonify({
        'success': True,
        'pairing_code': pairing_code,
        'expires_in': PAIRING_TOKEN_TTL
    })

@app.route('/api/extension/pair', methods=['POST'])
def pair_extension():
    """Extension'ı pairing kodu ile eşle"""
    # CORS için preflight
    if request.method == 'OPTIONS':
        return '', 204
    
    data = request.get_json()
    pairing_code = data.get('pairing_code', '').upper().strip()
    browser = data.get('browser', 'unknown')
    
    if not pairing_code:
        return jsonify({'error': 'Pairing kodu gerekli'}), 400
    
    # Süresi dolmuş tokenları temizle
    cleanup_expired_tokens()
    
    # Pairing kodunu kontrol et
    if pairing_code not in pairing_tokens:
        return jsonify({'error': 'Geçersiz veya süresi dolmuş pairing kodu'}), 400
    
    token_data = pairing_tokens[pairing_code]
    user_session_id = token_data['user_session_id']
    
    # Extension token oluştur
    ext_token = generate_extension_token()
    
    # Extension token'ı kaydet
    extension_tokens[ext_token] = {
        'user_session_id': user_session_id,
        'browser': browser,
        'paired_at': time.time(),
        'last_sync': None
    }
    
    # Pairing kodunu sil (tek kullanımlık)
    del pairing_tokens[pairing_code]
    
    print(f"[DEBUG] Extension paired: {ext_token[:20]}... for session: {user_session_id}, browser: {browser}", file=sys.stderr)
    
    return jsonify({
        'success': True,
        'extension_token': ext_token,
        'message': 'Extension başarıyla bağlandı'
    })

@app.route('/api/extension/verify', methods=['GET'])
def verify_extension():
    """Extension token geçerliliğini kontrol et"""
    ext_token = request.headers.get('X-Extension-Token')
    
    if not ext_token:
        return jsonify({'valid': False, 'error': 'Token gerekli'}), 401
    
    if ext_token not in extension_tokens:
        return jsonify({'valid': False, 'error': 'Geçersiz token'}), 401
    
    token_data = extension_tokens[ext_token]
    
    return jsonify({
        'valid': True,
        'browser': token_data['browser'],
        'paired_at': token_data['paired_at'],
        'last_sync': token_data['last_sync']
    })

@app.route('/api/extension/push-cookies', methods=['POST', 'OPTIONS'])
def push_cookies():
    """Extension'dan cookie'leri al"""
    # CORS preflight
    if request.method == 'OPTIONS':
        response = jsonify({'status': 'ok'})
        response.headers['Access-Control-Allow-Origin'] = '*'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, X-Extension-Token'
        response.headers['Access-Control-Allow-Methods'] = 'POST, OPTIONS'
        return response
    
    ext_token = request.headers.get('X-Extension-Token')
    
    if not ext_token:
        return jsonify({'error': 'Extension token gerekli'}), 401
    
    if ext_token not in extension_tokens:
        return jsonify({'error': 'Geçersiz extension token'}), 401
    
    # Rate limit kontrolü
    allowed, retry_after = check_rate_limit(ext_token)
    if not allowed:
        response = jsonify({
            'error': 'Rate limit aşıldı. Lütfen bekleyin.',
            'retry_after': retry_after
        })
        response.headers['Retry-After'] = str(retry_after)
        return response, 429
    
    data = request.get_json()
    cookies = data.get('cookies', [])
    
    if not cookies:
        return jsonify({'error': 'Cookie listesi boş'}), 400
    
    # Token bilgilerini al
    token_data = extension_tokens[ext_token]
    user_session_id = token_data['user_session_id']
    
    # Cookie'leri Netscape formatına çevir
    netscape_content = cookies_to_netscape(cookies)
    
    # Cookie dosyasını kaydet
    cookie_path = os.path.join(COOKIE_FOLDER, f'{user_session_id}.txt')
    
    try:
        with open(cookie_path, 'w') as f:
            f.write(netscape_content)
        
        # Son senkronizasyon zamanını güncelle
        extension_tokens[ext_token]['last_sync'] = time.time()
        
        print(f"[DEBUG] Cookies pushed from extension for session: {user_session_id}, count: {len(cookies)}", file=sys.stderr)
        
        return jsonify({
            'success': True,
            'message': f'{len(cookies)} cookie başarıyla kaydedildi',
            'synced_at': time.time()
        })
    except Exception as e:
        return jsonify({'error': f'Cookie kaydedilirken hata: {str(e)}'}), 500

@app.route('/api/extension/list', methods=['GET'])
def list_extensions():
    """Kullanıcının bağlı extension'larını listele"""
    session_id = session.get('session_id')
    
    if not session_id:
        return jsonify({'extensions': []})
    
    # Bu session'a bağlı extension'ları bul
    connected = []
    for ext_token, data in extension_tokens.items():
        if data['user_session_id'] == session_id:
            connected.append({
                'token_prefix': ext_token[:12] + '...',
                'browser': data['browser'],
                'paired_at': data['paired_at'],
                'last_sync': data['last_sync']
            })
    
    return jsonify({'extensions': connected})

@app.route('/api/extension/revoke', methods=['POST'])
def revoke_extension():
    """Extension bağlantısını kes"""
    session_id = session.get('session_id')
    
    if not session_id:
        return jsonify({'error': 'Oturum bulunamadı'}), 400
    
    data = request.get_json()
    token_prefix = data.get('token_prefix', '')
    
    # Token prefix ile eşleşen extension'ı bul ve sil
    to_delete = None
    for ext_token, ext_data in extension_tokens.items():
        if ext_data['user_session_id'] == session_id and ext_token.startswith(token_prefix.replace('...', '')):
            to_delete = ext_token
            break
    
    if to_delete:
        del extension_tokens[to_delete]
        # Rate limit verisini de temizle
        if to_delete in rate_limits:
            del rate_limits[to_delete]
        return jsonify({'success': True, 'message': 'Extension bağlantısı kesildi'})
    
    return jsonify({'error': 'Extension bulunamadı'}), 404

@app.route('/api/extension/pairing-status/<pairing_code>')
def get_pairing_status(pairing_code):
    """Pairing kodunun durumunu kontrol et"""
    cleanup_expired_tokens()
    
    if pairing_code in pairing_tokens:
        return jsonify({'status': 'pending'})
    
    # Token kullanılmış olabilir, session'da cookie var mı kontrol et
    session_id = session.get('session_id')
    if session_id:
        has_cookies = session.get('has_cookies', False)
        if has_cookies:
            return jsonify({'status': 'completed'})
    
    return jsonify({'status': 'expired'})

# CORS middleware for extension requests
@app.after_request
def add_cors_headers(response):
    """Extension istekleri için CORS header'ları ekle"""
    if request.path.startswith('/api/extension/'):
        response.headers['Access-Control-Allow-Origin'] = '*'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, X-Extension-Token'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'
    return response

# ============ Main Routes ============

@app.route('/health')
def health_check():
    """Health check endpoint - Railway uses this to check if app is alive"""
    return jsonify({
        'status': 'ok',
        'message': 'Application is running',
        'timestamp': time.time()
    })

@app.route('/ping')
def ping():
    """Simple ping endpoint for keep-alive"""
    return 'pong', 200

@app.route('/cleanup')
def manual_cleanup():
    """Manuel temizlik endpoint'i"""
    expired_tokens = cleanup_expired_tokens()
    expired_downloads = cleanup_old_downloads()
    return jsonify({
        'cleaned_tokens': expired_tokens,
        'cleaned_downloads': expired_downloads
    })

@app.route('/privacy-policy')
def privacy_policy():
    """Gizlilik politikası sayfası"""
    return send_from_directory('docs', 'privacy-policy.html')

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/info', methods=['POST'])
def get_info():
    """Video bilgilerini getir"""
    data = request.get_json()
    url = data.get('url')
    
    if not url:
        return jsonify({'error': 'URL gerekli'}), 400
    
    # URL whitelist kontrolü (XSS önleme)
    youtube_pattern = r'^https?://(www\.)?(youtube\.com/watch\?v=|youtu\.be/|youtube\.com/shorts/)'
    if re.match(youtube_pattern, url):
        # YouTube URL'si - sadece video ID'si ve bazı parametrelere izin ver
        pass  # YouTube URL'leri güvenli
    elif not url.startswith('http://') and not url.startswith('https://'):
        return jsonify({'error': 'Geçersiz URL formatı'}), 400
    
    cookie_file = get_user_cookie_file()
    
    try:
        info = get_video_info(url, cookie_file)
        info['has_cookies'] = session.get('has_cookies', False)
        return jsonify(info)
    except Exception as e:
        error_msg = str(e)
        if 'Sign in to confirm your age' in error_msg or 'age' in error_msg.lower():
            return jsonify({
                'error': 'Bu video yaş kısıtlamalı. Lütfen cookie dosyanızı yükleyin.',
                'requires_cookies': True
            }), 403
        return jsonify({'error': error_msg}), 400

@app.route('/api/download', methods=['POST'])
def start_download():
    """İndirme başlat"""
    data = request.get_json()
    url = data.get('url')
    format_id = data.get('format_id', 'best')
    
    if not url:
        return jsonify({'error': 'URL gerekli'}), 400
    
    download_id = str(uuid.uuid4())[:8]
    cookie_file = get_user_cookie_file()
    print(f"[DEBUG] start_download - Cookie file: {cookie_file}", file=sys.stderr)
    
    thread = threading.Thread(target=download_video, args=(url, format_id, download_id, cookie_file))
    thread.start()
    
    return jsonify({'download_id': download_id})

@app.route('/api/status/<download_id>')
def get_status(download_id):
    """İndirme durumunu kontrol et"""
    if download_id not in download_status:
        return jsonify({'error': 'İndirme bulunamadı'}), 404
    
    return jsonify(download_status[download_id])

@app.route('/api/file/<download_id>')
def get_file(download_id):
    """İndirilen dosyayı gönder"""
    if download_id not in download_status:
        return jsonify({'error': 'İndirme bulunamadı'}), 404
    
    status = download_status[download_id]
    if status['status'] != 'completed':
        return jsonify({'error': 'İndirme henüz tamamlanmadı'}), 400
    
    filename = status['filename']
    filepath = os.path.join(DOWNLOAD_FOLDER, filename)
    
    if not os.path.exists(filepath):
        return jsonify({'error': 'Dosya bulunamadı'}), 404
    
    clean_filename = sanitize_filename(filename[len(download_id)+1:])
    
    response = send_file(filepath, as_attachment=True, download_name=clean_filename)
    
    def cleanup():
        import time
        time.sleep(60)
        try:
            os.remove(filepath)
            if download_id in download_status:
                del download_status[download_id]
        except:
            pass
    
    threading.Thread(target=cleanup, daemon=True).start()
    
    return response

if __name__ == '__main__':
    app.run(debug=True, port=5000)
